https://blog.csdn.net/m0_38030271/article/details/80089397?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-80089397.nonecase&utm_term=%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A&spm=1000.2123.3001.4430

业务场景： 支付模块，如果用户已经付款成功了，但是在本身接口更改支付状态时出错

**调用第三方接口操作数据成功后，如果自己本身接口报错，更新本地数据失败了，如何实现事务回滚？**

示例：本地项目需要推送订单的状态到第三方接口，并根据返回值更新本地订单状态为已推送，如果在第三方处处理成功并返回标识，但是在本地更新订单状态时出错了，就造成了本地数据和第三方数据不一致的情况。

解决：思路如下，可以先默认更改本地订单状态为已推送，然后调用三方接口，根据接口返回值进行回滚

1.创建事务

2.更新本地订单状态（失败则回滚）

3.调用第三方接口

4.根据接口返回值决定事务提交还是回滚

这样首先保证了本地数据能够更新，再根据接口返回值判断是否更新。

这种方法只是针对单一操作，如果是大量的批量操作，建议使用队列进行异步处理。



**问题一：**

在事务中去请求第三方接口，容易导致事务时间过长，对方接口超时多久，你的db事务也卡多久





https://blog.csdn.net/diaoyuanrui9456/article/details/101866275?utm_medium=distribute.pc_relevant.none-task-blog-utm_term-3&spm=1001.2101.3001.4242

###### 设计方案

往两个方面思考

1. 自己系统本身数据一致性
2. 如果调用第三方接口 和 更新自己系统数据 之间任何一个环节 出异常了。比如：程序报错，服务器宕机，网络异常问题等。如何保证第三方接口和自己系统的数据一致性？

方案

1. 加锁，方案有：版本号乐观锁、select for update 悲观锁。
   延伸问题：在原表上执行task，还是队列表？
2. 第三方接口需要什么特性才能保证数据一致性？ 要考虑网络超时问题、应用发布重启、并发等问题。

- 回调
- 提供结果查询
- 幂等性



```php
try {
    // 前置逻辑
    
    // 事务开启
    beginTransaction();

    // 调用支付中心返现接口
    callCommission($order);  //无论是网络异常还是返回结果失败，都抛异常

    // 更改订单状态
    cashedOrder(order); //更改订单状态

    // 事务提交，保存入库
    commit();
} catch (\Throwable $th) {
    // 回滚业务状态
}
```

   

**问题二：**

在调用接口和 更改状态之间，是否有其他操作能改变该订单状态？

如果有，是否会出现多次调用第三方的问题？（接口幂等性）



###### 重构后的示例1:

(幂等接口的方案)

```java
queueOrders = queryQueueOrders();
for (QueueOrder order : queueOrders){
    callApi()
    startTransaction();
    lock(order);
    updateStatus()
    commitTransaction();
}
```

(提供结果查询的API接口的方案)

```java
queueOrders = queryQueueOrders();
for (QueueOrder order : queueOrders){
    try {
       startTransaction();
       if (isBeingProcess(order)){
           Result r = queryAPIResult();
           if (r.success()){
             return ;
           }
       }
       lock(order);
       callApi()
       updateStatus();
    } finally {
    commitTransaction();
    }
}
```



https://blog.csdn.net/linsongbin1/article/details/80092824?utm_medium=distribute.pc_relevant.none-task-blog-title-4&spm=1001.2101.3001.4242

# 连续调用多个外部系统的写接口-如何保证数据一致性(思路)

某些场景下，我们将业务数据落地之前，是需要先调用外部系统的多个写接口，当这些写接口都操作成功了，我们才将业务数据落地到自己本地的数据库里面。比如说：



```java
public void updateProductInfo(Product product) 
{
    //1、将商品价格更新到价格系统
    priceService.updatePrice(product);
    
    //2、将库存信息更新库存系统
    stockService.updateStock(product);

    //3、将商品更新到本地数据库
    productService.updateProduct(product);
}
```
就上面这个例子(**例子是虚构的,只是为了说明问题而已**)，它的执行路径有几种：

1、调用价格系统、库存系统的操作以及保存数据到本地DB都正常；
2、调用价格系统接口的时候就抛异常了;
3、调用价格系统接口正常，但是调用库存系统的接口有异常;
4、调用价格系统和库存系统的接口都正常了，但是将商品数据更新到本地数据库出现异常。

如果是第一和第二这两种情况，无需考虑数据一致性问题，但是如果出现了第三和第四这两种情况，我们就得根据业务实际情况，考虑如何保证数据的一致性。

这里说的保证数据一致性，必须是由`调用方`来保证的，服务端是无法保证的。

------

# 重试和操作日志

------

以上面提到的第三种情况来说明一下。

> 调用价格系统接口正常，但是调用库存系统的接口有异常。

#### 库存接口允许重试

如果库存系统接口是幂等的,那么调用方可以使用重试的机制，多调用几次，比如说3次。如果还是不成功，那之前价格系统接口的操作就得走反向操作,进行现场恢复。

#### 库存接口不允许重试

价格系统接口的操作得走反向操作，进行现场恢复

------

要实现反向操作，恢复现场，有一种办法是使用分布式事务，但是实现起来实在太复杂了，性能也不好。可以尝试使用`操作日志`来恢复现场。比如说，价格系统调用成功了，把这个操作状态以及相关的业务数据记录起来，当库存操作失败后，利用操作日志里的数据，将之前的价格操作恢复回来。这个恢复操作，价格系统可以单独提供出一个接口。

如果恢复现场的操作也失败了，这个时候只能人工介入解决了。没其他办法了。



**问题：**

如果在恢复之前有其他请求修改了之前价格呢，直接恢复到当时的状态不是影响其他业务了吗？如果在不影响其他业务请求情况下实现恢复，又太过复杂了，要考虑更新的各种细节，这个问题怎么解决？





# 谈谈如何确保数据的一致性

### 谈谈如何确保数据的一致性

- 数据库必须具备的四个特
- 背景
- 什么是接口的幂等性
- 幂等性在哪里会用到
- 技术方案
- 总结

参考 https://blog.csdn.net/u011635492/article/details/81058153

特性

1：原子性：事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库产生影响；
2：一致性：事务执行前和执行后必须处于一致性状态，
例：用户A和用户B的前加起来一共是5000; 无论AB用户之间是如何相互转换的，事务结束后两个用户的钱加起来还是5000,这就是事务的一致性。

3：隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离；

4：持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。

# 背景

最近一个金融项目上线后出现了严重的车祸现场，用户资产数据出现脏数据（资产负数，一笔订单变成四笔订单，平白无故多出的钱）。随后根据数据库一一排查：
1.前端重复提交选中的数据，后台产生可能后产生多个响应结果，数据不能保持一致性。
2.用户发起一笔付款请求，如果遇到网络超时，同一个请求重复发送多次，可能造成用户账号多次扣款。
3.创建业务订单时，一次业务请求可能会产生多个订单。
**所以保持接口的幂等性很重要。**

# 什么是接口的幂等性？

数学上的定义是f(f(x))=f(x)，x被函数f作用了一次或无数次的结果都是一样的。
在软件系统中定义是，当一个函数或一个接口被相同的参数调用一次或无数次结果都是一致的。
我们也可以说是确保数据的一致性。

# 幂等性在哪里会用到？

1.前端重复提交选中的数据，后台应该只产生对应本次提交的一个响应结果。
2.用户发起一笔付款请求，应该只扣除用户账号一次钱，即使遇到网络重发或系统bug重发是，也只扣除一次钱。
3.创建业务订单是，一次业务请求只能创建一个订单。

# 技术方案

1. **唯一索引**，防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引。以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过；②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；
2. **token机制**，防止页面重复提交。业务要求： 页面的数据只能被点击提交一次；发生原因： 由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交；解决办法： 集群环境采用token加redis(redis单线程的，处理需要排队)；单JVM环境：采用token加redis或token加jvm内存。处理流程：1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间；2. 提交后后台校验token，同时删除token，生成新的token返回。token特点：要申请，一次有效性，可以限流。注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用；
   悲观锁——获取数据的时候加锁获取。select * from table_xxx where id=‘xxx’ for update; 注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；
3. **悲观锁**——获取数据的时候加锁获取。select * from table_xxx where id=‘xxx’ for update;
   注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；
4. **乐观锁**——每次去拿数据的时候，都认为别人不会修改，不会加锁，但在更新的时候会去判断一下，此期间别人有没有更新数据，版本号机制和CAS算法就用到乐观锁，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：
   - 通过版本号实现update table_xxx set name=#name#,version=version+1 where
     version=#version#；
   - 通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >=0要求：quality-#subQuality# >=
     ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高；但是，乐观锁存在失效的情况，就是常说的ABA问题。如果version版本一直是自增的就不会出现ABA的情况。
     参考——乐观锁版本号机制值CAS：https://www.cnblogs.com/cwb123/articles/10847043.html
     拓展——CAS下ABA问题及优化方案：https://mp.weixin.qq.com/s/xMoQk99N2gyz7ftBfcTLGQ
5. **分布式锁**——还是拿插入数据的例子，如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入了多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)；
6. **select + insert**——并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；
7. **状态机幂等**——在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助 。
8. 对外提供接口的api如何保证幂等。如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 。
9. source+seq在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求)
   。重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。
10. **支付缓冲区**：把订单的支付请求都快速地接下来，一个快速接单的缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的待支付订单。优点是同步转异步，高吞吐量。缺点是不能及时地返回支付结果，需要后续监听支付结果的异步返回。

# 总结

接口的幂等性处理与数据设计，业务流程有着密切关联，像资产，钱包，交易所，这些都是与钱打交道的，数据的安全，准确还有一致性更要谨慎，如果处理不好会影响用户体验度。

- 接口开发时，要对异常参数进行校验，对于一些不可逆的操作，操作之前一定要让用户再确认一遍，比如删除订单，转账等…
- 对于账户资产的操作，该加事务、乐观锁的地方都加上，高并发时是很可能出现问题： 账户划转，连续划转，转出账户扣一次钱，转入账户加两次钱
  1. 取消订单，订单取消成功，但是冻结金额直接没了，没加回到可用金额里面 对于数据校验的顺序问题
  2. 用户下单，生成订单前检验了余额，这时候打个断点，在另一个浏览器登录这个账号 ，再次下单，这时放开第一个订单的断点，会生成两个订单
- 注意数据库记录的时间，不插入时间的，调用时就会显示1970-01-0100:00:00，或者插
  了服务器本地时间的，如果服务器是国外的，数据就错误了