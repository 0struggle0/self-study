https://blog.csdn.net/m0_38030271/article/details/80089397?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-80089397.nonecase&utm_term=%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A&spm=1000.2123.3001.4430

业务场景： 支付模块，如果用户已经付款成功了，但是在本身接口更改支付状态时出错

**调用第三方接口操作数据成功后，如果自己本身接口报错，更新本地数据失败了，如何实现事务回滚？**

示例：本地项目需要推送订单的状态到第三方接口，并根据返回值更新本地订单状态为已推送，如果在第三方处处理成功并返回标识，但是在本地更新订单状态时出错了，就造成了本地数据和第三方数据不一致的情况。

解决：思路如下，可以先默认更改本地订单状态为已推送，然后调用三方接口，根据接口返回值进行回滚

1.创建事务

2.更新本地订单状态（失败则回滚）

3.调用第三方接口

4.根据接口返回值决定事务提交还是回滚

这样首先保证了本地数据能够更新，再根据接口返回值判断是否更新。

这种方法只是针对单一操作，如果是大量的批量操作，建议使用队列进行异步处理。



**问题一：**

在事务中去请求第三方接口，容易导致事务时间过长，对方接口超时多久，你的db事务也卡多久





https://blog.csdn.net/diaoyuanrui9456/article/details/101866275?utm_medium=distribute.pc_relevant.none-task-blog-utm_term-3&spm=1001.2101.3001.4242

###### 设计方案

往两个方面思考

1. 自己系统本身数据一致性
2. 如果调用第三方接口 和 更新自己系统数据 之间任何一个环节 出异常了。比如：程序报错，服务器宕机，网络异常问题等。如何保证第三方接口和自己系统的数据一致性？

方案

1. 加锁，方案有：版本号乐观锁、select for update 悲观锁。
   延伸问题：在原表上执行task，还是队列表？
2. 第三方接口需要什么特性才能保证数据一致性？ 要考虑网络超时问题、应用发布重启、并发等问题。

- 回调
- 提供结果查询
- 幂等性



```php
try {
    // 前置逻辑
    
    // 事务开启
    beginTransaction();

    // 调用支付中心返现接口
    callCommission($order);  //无论是网络异常还是返回结果失败，都抛异常

    // 更改订单状态
    cashedOrder(order); //更改订单状态

    // 事务提交，保存入库
    commit();
} catch (\Throwable $th) {
    // 回滚业务状态
}
```

   

**问题二：**

在调用接口和 更改状态之间，是否有其他操作能改变该订单状态？

如果有，是否会出现多次调用第三方的问题？（接口幂等性）



###### 重构后的示例1:

(幂等接口的方案)

```java
queueOrders = queryQueueOrders();
for (QueueOrder order : queueOrders){
    callApi()
    startTransaction();
    lock(order);
    updateStatus()
    commitTransaction();
}
```

(提供结果查询的API接口的方案)

```java
queueOrders = queryQueueOrders();
for (QueueOrder order : queueOrders){
    try {
       startTransaction();
       if (isBeingProcess(order)){
           Result r = queryAPIResult();
           if (r.success()){
             return ;
           }
       }
       lock(order);
       callApi()
       updateStatus();
    } finally {
    commitTransaction();
    }
}
```



https://blog.csdn.net/linsongbin1/article/details/80092824?utm_medium=distribute.pc_relevant.none-task-blog-title-4&spm=1001.2101.3001.4242

# 连续调用多个外部系统的写接口-如何保证数据一致性(思路)

某些场景下，我们将业务数据落地之前，是需要先调用外部系统的多个写接口，当这些写接口都操作成功了，我们才将业务数据落地到自己本地的数据库里面。比如说：



```java
public void updateProductInfo(Product product) 
{
    //1、将商品价格更新到价格系统
    priceService.updatePrice(product);
    
    //2、将库存信息更新库存系统
    stockService.updateStock(product);

    //3、将商品更新到本地数据库
    productService.updateProduct(product);
}
```
就上面这个例子(**例子是虚构的,只是为了说明问题而已**)，它的执行路径有几种：

1、调用价格系统、库存系统的操作以及保存数据到本地DB都正常；
2、调用价格系统接口的时候就抛异常了;
3、调用价格系统接口正常，但是调用库存系统的接口有异常;
4、调用价格系统和库存系统的接口都正常了，但是将商品数据更新到本地数据库出现异常。

如果是第一和第二这两种情况，无需考虑数据一致性问题，但是如果出现了第三和第四这两种情况，我们就得根据业务实际情况，考虑如何保证数据的一致性。

这里说的保证数据一致性，必须是由`调用方`来保证的，服务端是无法保证的。

------

# 重试和操作日志

------

以上面提到的第三种情况来说明一下。

> 调用价格系统接口正常，但是调用库存系统的接口有异常。

#### 库存接口允许重试

如果库存系统接口是幂等的,那么调用方可以使用重试的机制，多调用几次，比如说3次。如果还是不成功，那之前价格系统接口的操作就得走反向操作,进行现场恢复。

#### 库存接口不允许重试

价格系统接口的操作得走反向操作，进行现场恢复

------

要实现反向操作，恢复现场，有一种办法是使用分布式事务，但是实现起来实在太复杂了，性能也不好。可以尝试使用`操作日志`来恢复现场。比如说，价格系统调用成功了，把这个操作状态以及相关的业务数据记录起来，当库存操作失败后，利用操作日志里的数据，将之前的价格操作恢复回来。这个恢复操作，价格系统可以单独提供出一个接口。

如果恢复现场的操作也失败了，这个时候只能人工介入解决了。没其他办法了。



**问题：**

如果在恢复之前有其他请求修改了之前价格呢，直接恢复到当时的状态不是影响其他业务了吗？如果在不影响其他业务请求情况下实现恢复，又太过复杂了，要考虑更新的各种细节，这个问题怎么解决？





# 谈谈如何确保数据的一致性

### 谈谈如何确保数据的一致性

- 数据库必须具备的四个特
- 背景
- 什么是接口的幂等性
- 幂等性在哪里会用到
- 技术方案
- 总结

参考 https://blog.csdn.net/u011635492/article/details/81058153

特性

1：原子性：事务包含的所有操作要么全部成功，要么全部失败回滚;成功必须要完全应用到数据库，失败则不能对数据库产生影响；
2：一致性：事务执行前和执行后必须处于一致性状态，
例：用户A和用户B的前加起来一共是5000; 无论AB用户之间是如何相互转换的，事务结束后两个用户的钱加起来还是5000,这就是事务的一致性。

3：隔离性：当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离；

4：持久性：一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。

# 背景

最近一个金融项目上线后出现了严重的车祸现场，用户资产数据出现脏数据（资产负数，一笔订单变成四笔订单，平白无故多出的钱）。随后根据数据库一一排查：
1.前端重复提交选中的数据，后台产生可能后产生多个响应结果，数据不能保持一致性。
2.用户发起一笔付款请求，如果遇到网络超时，同一个请求重复发送多次，可能造成用户账号多次扣款。
3.创建业务订单时，一次业务请求可能会产生多个订单。
**所以保持接口的幂等性很重要。**

# 什么是接口的幂等性？

数学上的定义是f(f(x))=f(x)，x被函数f作用了一次或无数次的结果都是一样的。
在软件系统中定义是，当一个函数或一个接口被相同的参数调用一次或无数次结果都是一致的。
我们也可以说是确保数据的一致性。

# 幂等性在哪里会用到？

1.前端重复提交选中的数据，后台应该只产生对应本次提交的一个响应结果。
2.用户发起一笔付款请求，应该只扣除用户账号一次钱，即使遇到网络重发或系统bug重发是，也只扣除一次钱。
3.创建业务订单是，一次业务请求只能创建一个订单。

# 技术方案

1. **唯一索引**，防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引。以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过；②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；
2. **token机制**，防止页面重复提交。业务要求： 页面的数据只能被点击提交一次；发生原因： 由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交；解决办法： 集群环境采用token加redis(redis单线程的，处理需要排队)；单JVM环境：采用token加redis或token加jvm内存。处理流程：1. 数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间；2. 提交后后台校验token，同时删除token，生成新的token返回。token特点：要申请，一次有效性，可以限流。注意：redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用；
   悲观锁——获取数据的时候加锁获取。select * from table_xxx where id=‘xxx’ for update; 注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；
3. **悲观锁**——获取数据的时候加锁获取。select * from table_xxx where id=‘xxx’ for update;
   注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；
4. **乐观锁**——每次去拿数据的时候，都认为别人不会修改，不会加锁，但在更新的时候会去判断一下，此期间别人有没有更新数据，版本号机制和CAS算法就用到乐观锁，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：
   - 通过版本号实现update table_xxx set name=#name#,version=version+1 where
     version=#version#；
   - 通过条件限制 update table_xxx set avai_amount=avai_amount-#subAmount# where avai_amount-#subAmount# >=0要求：quality-#subQuality# >=
     ，这个情景适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高；但是，乐观锁存在失效的情况，就是常说的ABA问题。如果version版本一直是自增的就不会出现ABA的情况。
     参考——乐观锁版本号机制值CAS：https://www.cnblogs.com/cwb123/articles/10847043.html
     拓展——CAS下ABA问题及优化方案：https://mp.weixin.qq.com/s/xMoQk99N2gyz7ftBfcTLGQ
5. **分布式锁**——还是拿插入数据的例子，如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入了多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)；
6. **select + insert**——并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；
7. **状态机幂等**——在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助 。
8. 对外提供接口的api如何保证幂等。如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号 。
9. source+seq在数据库里面做唯一索引，防止多次付款(并发时，只能处理一个请求)
   。重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。
10. **支付缓冲区**：把订单的支付请求都快速地接下来，一个快速接单的缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的待支付订单。优点是同步转异步，高吞吐量。缺点是不能及时地返回支付结果，需要后续监听支付结果的异步返回。

# 总结

接口的幂等性处理与数据设计，业务流程有着密切关联，像资产，钱包，交易所，这些都是与钱打交道的，数据的安全，准确还有一致性更要谨慎，如果处理不好会影响用户体验度。

- 接口开发时，要对异常参数进行校验，对于一些不可逆的操作，操作之前一定要让用户再确认一遍，比如删除订单，转账等…
- 对于账户资产的操作，该加事务、乐观锁的地方都加上，高并发时是很可能出现问题： 账户划转，连续划转，转出账户扣一次钱，转入账户加两次钱
  1. 取消订单，订单取消成功，但是冻结金额直接没了，没加回到可用金额里面 对于数据校验的顺序问题
  2. 用户下单，生成订单前检验了余额，这时候打个断点，在另一个浏览器登录这个账号 ，再次下单，这时放开第一个订单的断点，会生成两个订单
- 注意数据库记录的时间，不插入时间的，调用时就会显示1970-01-0100:00:00，或者插
  了服务器本地时间的，如果服务器是国外的，数据就错误了





## 场景

> 客户端调用A服务的接口，A服务接口中又调用了B服务。 如果A服务和B服务都执行成功，则成功，并且二者事务都应提交； 如果A服务或B服务任意一个失败，则失败，且二者事务都不执行或回滚。 因为网络请求的不可靠性，如果A调用B失败，可能：1. B没有接收到网络请求；2. B收到后执行失败; 3. B执行成功，请求返回时异常。 4. B调用超时，B可能执行成功也可能失败。因此当A调用B时，可能出现不一致。

## 接口调用几种方式

### 方式一：feign直接调用

A服务接口:

```
try {
    业务代码A
    feign调用B服务接口
    事务提交
} catch (Exception e) {
    事务回滚
}
复制代码
```

B服务接口:

```
try {
    业务代码B
    事务提交
    //此时接口状态码2XX
} catch (Exception e) {
    事务回滚
    //此时接口状态码非2XX
}
复制代码
```

一致性分析:

1. feign调用B服务接口成功，状态码为2XX。则B服务事务已经提交，A进行事务提交。 若A事务提交成功，则一致； 若A事务提交失败但此时B中事务已经提交，则不一致。
2. B没有接收到网络请求。B未被执行，feign调用抛出异常，A事务不进行提交，进入回滚，数据一致。
3. B执行成功，请求返回时异常。B事务已经提交，feign调用B服务接口异常，A事务回滚，数据不一致。
4. B调用超时。可能为B没有接收到网络请求，也可能B执行成功，请求返回时异常，也可能B收到请求响应缓慢。一致性状态不确定，都有可能。

### 方式二：基于可靠消息

> 服务A业务代码执行完后发送消息到消息队列，如rabbitmq，并用ack等方式确保发送成功； B服务接收消费成功后，手动确认消息，kafka则用手动提交位移的方式。

A服务生产者:

```
try {
    业务代码A
    ack = rabbitmqProducer.sendAndGetAck
    if !ack {
        //发送失败可以设置自动重试，不重试就抛出异常
        throws new RabbitmqSendException
    }
    事务提交
} catch (Exception e) {
    //事务回滚
}
复制代码
```

B服务消息队列消费端一:

```
//
try {
    业务代码B
    channel.basicAck手动确认//kafka则手动提交位移
    事务提交
    //此时接口状态码2XX
} catch (Exception e) {
    事务回滚
    //此时接口状态码非2XX
}
复制代码
```

B服务消息队列消费端二:

```
//
try {
    业务代码B
    事务提交
    //此时接口状态码2XX
} catch (Exception e) {
    事务回滚
    //此时接口状态码非2XX
}
channel.basicAck手动确认//kafka则手动提交位移
复制代码
```

一致性分析:

1. A服务发送消息到消息队列成功，却提交事务失败，出现数据不一致。
2. B消费端一：手动确认后，消息从消息队列删除，B事务提交失败，出现数据不一致。
3. B消费端二：B事务提交成功，手动确认失败，可能会重复收到该条消息，出现不一致。 此时可在消息中添加uuid，服务B收到消息后根据uuid进行一次去重再处理等方式来实现幂等性。

### 方式三：预执行+确认+回查，类似TCC

A服务需要插入一个表transaction_record记录调用状态，提供给B服务回调。

A服务业务接口:

```
String uuid = generateUUID()//生成一个uuid
try{
    feign.preCreate(uuid,...)//feign调用B预执行，比如B服务为创建订单服务，预创建一个订单，但状态为待确认
    业务代码A
    将uuid插入transaction_record表中
    事务提交
}catch (Exception e) {
    事务回滚
    feign.cancel(uuid)//feign调用B取消，比如B服务为创建订单服务，设置该订单状态为取消
}
 
feign.confirm(uuid)//feign调用B确认，比如B服务为创建订单服务，设置该订单状态为确认，此时订单可用 
复制代码
```

A服务服务回查接口，提供给B服务回查状态:

```
get /v1/transaction/{uuid}
 
从transaction_record表中查询，有则返回确认，没有则返回取消
复制代码
```

B服务需要提供预执行、确认、取消接口。若预执行后迟迟没有执行确认或取消，则B向A回查，根据结果确认或取消。

一致性分析：

1. A中preCreate执行异常。应抛出异常，不再执行业务代码和事件表插入uuid，去执行cancel。若B执行则状态也为未确认，不影响一致性； 若cancel也执行失败，比如此时B挂掉，B重启后应去调用服务A的回查接口，确定状态。状态一致。
2. 业务代码A执行失败，事务回滚，feign调用B取消。若取消成功，则状态一致；若取消失败，应抛出异常，confirm不再执行。状态一致。
3. 业务代码A执行成功，事务提交失败，执行事务回滚。若回滚失败，抛出异常，不再执行cancel和confirm，B会执行超时回查确定状态；若回滚成功，则执行取消。状态一致。
4. A事务提交成功，确认失败(比如A执行确认时，服务A或者B刚好挂掉)。则服务B超时回查，发现uuid存在，修改状态为确认。状态一致。
5. 预处理完成后，去执行业务代码，若业务代码执行缓慢，B服务认为超时，则服务B超时回查，若A的事务还未提交，A的回查接口返回取消， 则B被取消，A却提交了事务，此时出现事务状态的不一致。此时可以通过设置B稍微大的超时时间来调整，可以让服务A在预处理的feign调用时传入期待的超时时间。

## 总结

以上是接口间调用的几种方式，这里只提供一种大概的思路，应用时可以自己优化，同步发送也可修改为异步+重试等方式。 若一致性要求可采用方式三，uuid+插入表也可采用其他的方式实现。为了提高一致性，接口调用也要尽量是幂等的，可通过业务逻辑的幂等性或 uuid实现。