<?php

#***************************************************************************************************************************
# 1. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
// 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
// 示例:
// 给定 nums = [2, 7, 11, 15], target = 9
// 因为 nums[0] + nums[1] = 2 + 7 = 9
// 所以返回 [0, 1]
#***************************************************************************************************************************

// 解法一 self (暴力破解)  时间复杂度O(n^2)  空间复杂度O(1)
// function twoSum($nums, $target) {
//     foreach ($nums as $key => $num) {
//         foreach ($nums as $keyBak => $numBak) {
//             if ($key != $keyBak && ($num + $numBak == $target)) {
//                 return array($key, $keyBak);
//             }
//         }
//     }
// }

// 解法二 self 时间复杂度降为O(n) 
// function twoSum($nums, $target)
// {
//     $find = [];
//     foreach ($nums as $index => $value) {
//         $otherIndex = array_keys($find, ($target - $value));

//         if ($otherIndex) {
//             return [$otherIndex[0], $index];
//         }

//         $find[$index] = $value;
//     }
// }

// var_dump(twoSum(array(3, 2, 4), 6));


#***************************************************************************************************************************
# 2. 删去字符串中的元音
// 示例:
// 输入："leetcodeisacommunityforcoders"
// 输出："ltcdscmmntyfrcdrs"
#***************************************************************************************************************************

// $initString = 'leetcodeisacommunityforcoders';
// $endString = str_replace(array('a', 'e', 'i', 'o', 'u'), '', $initString);
// var_dump($endString);

#***************************************************************************************************************************
# 3. 猜数字   
// 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？
// 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。

// 示例 1：
// 输入：guess = [1,2,3], answer = [1,2,3]
// 输出：3
// 解释：小A 每次都猜对了。

// 示例 2：
// 输入：guess = [2,2,3], answer = [3,2,1]
// 输出：1
// 解释：小A 只猜对了第二次。

// 限制：
// guess的长度 = 3
// answer的长度 = 3
// guess的元素取值为 {1, 2, 3} 之一。
// answer的元素取值为 {1, 2, 3} 之一。
#***************************************************************************************************************************

// $array1 = array(1, 2, 3);
// $array2 = array(1, 2, 3);

// 方法一
// $result = count(array_intersect_assoc($array1, $array2));

// 方法二  只适用于知道规模小的数据且有限
// $result = ($array1[0]==$array2[0]?1:0)+($array1[1]==$array2[1]?1:0)+($array1[2]==$array2[2]?1:0);
// var_dump($result);

#***************************************************************************************************************************
# 3. 宝石与石头
// 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
// J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

// 示例 1:
// 输入: J = "aA", S = "aAAbbbb"
// 输出: 3
// 示例 2:

// 示例 2:
// 输入: J = "z", S = "ZZ"
// 输出: 0
// 注意:

// 提示：
// S 和 J 最多含有50个字母。
// J 中的字符不重复。
#***************************************************************************************************************************

// 方法一(self)
// function numJewelsInStones($J, $S) {
//     $JArray = str_split($J);
//     $SArray = str_split($S);
//     return count(array_intersect($SArray, $JArray));
// }
// 执行结果：通过
// 执行用时 : 4 ms, 在所有 php 提交中击败了 97.71% 的用户
// 内存消耗 : 15.1 MB, 在所有 php 提交中击败了 5.51% 的用户

// 方法二
// function numJewelsInStones($J, $S) {
//     return count(array_intersect(str_split($S), str_split($J)));
// }
// 有时代码行数少了不见得效率就高
// 执行结果：通过
// 执行用时 : 12 ms, 在所有 php 提交中击败了 27.43% 的用户
// 内存消耗 : 15 MB, 在所有 php 提交中击败了 5.51% 的用户

// 方法三
// function numJewelsInStones($J, $S) {
//     return strlen($S) - strlen(str_replace(str_split($J), '', $S));
// }
// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了 71.43% 的用户
// 内存消耗 : 14.8 MB, 在所有 php 提交中击败了 19.27% 的用户

// 方法四
// function numJewelsInStones($J, $S)
// {
//     $countJ = strlen($J);
//     if ($countJ == 0) {
//         return 0;
//     }
    
//     $out = 0;
//     $hash = [];
//     $countS = strlen($S);
//     for ($i = 0; $i < $countJ; $i++) {
//         $hash[$J[$i]] = 1;
//     }

//     for ($i = 0; $i < $countS; $i++) {
//         if (isset($hash[$S[$i]])) {
//             $out++;
//         }
//     }
//     return $out;
// }
// 执行结果：通过
// 执行用时 : 12 ms, 在所有 php 提交中击败了 27.43% 的用户
// 内存消耗 : 15 MB, 在所有 php 提交中击败了 5.51% 的用户

// 方法五
// function numJewelsInStones($J, $S)
// {
//     $bao = str_split($J);
//     $i = 0;
//     foreach ($bao as $v) {
//         $i += substr_count($S, $v);
//     }
//     return $i;
// }
// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了 71.43% 的用户
// 内存消耗 : 14.8 MB, 在所有 php 提交中击败了 26.61% 的用户


#***************************************************************************************************************************
# 4. 单行键盘
// 我们定制了一款特殊的力扣键盘，所有的键都排列在一行上。
// 我们可以按从左到右的顺序，用一个长度为 26 的字符串 keyboard （索引从 0 开始，到 25 结束）来表示该键盘的键位布局。
// 现在需要测试这个键盘是否能够有效工作，那么我们就需要个机械手来测试这个键盘。
// 最初的时候，机械手位于左边起第一个键（也就是索引为 0 的键）的上方。当机械手移动到某一字符所在的键位时，就会在终端上输出该字符。
// 机械手从索引 i 移动到索引 j 所需要的时间是 |i - j|。
// 当前测试需要你使用机械手输出指定的单词 word，请你编写一个函数来计算机械手输出该单词所需的时间。

// 示例 1:
// 输入：keyboard = "abcdefghijklmnopqrstuvwxyz", word = "cba"
// 输出：4
// 解释：
// 机械手从 0 号键移动到 2 号键来输出 'c'，又移动到 1 号键来输出 'b'，接着移动到 0 号键来输出 'a'。
// 总用时 = 2 + 1 + 1 = 4. 

// 示例 2:
// 输入：keyboard = "pqrstuvwxyzabcdefghijklmno", word = "leetcode"
// 输出：73

// 提示：
// keyboard.length == 26
// keyboard 按某种特定顺序排列，并包含每个小写英文字母一次。
// 1 <= word.length <= 10^4
// word[i] 是一个小写英文字母
#***************************************************************************************************************************
// function calculateTime($keyboard, $word)
// {
//     $time = 0;
//     $lastIndex = 0;
//     $wordLength = strlen($word);
//     for ($i = 0; $i < $wordLength; $i++) {
//         $currentIndex = strpos($keyboard, $word[$i]);
//         if ($currentIndex !== false) {
//             $time += abs($lastIndex - $currentIndex);
//             $lastIndex = $currentIndex;
//         }
//     }

//     return $time;
// }

// var_dump(calculateTime("pqrstuvwxyzabcdefghijklmno", "leetcode"));

#***************************************************************************************************************************
# 5. 整数的各位积和之差
// 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。

// 示例 1：
// 输入：n = 234
// 输出：15 
// 解释：
// 各位数之积 = 2 * 3 * 4 = 24 
// 各位数之和 = 2 + 3 + 4 = 9 
// 结果 = 24 - 9 = 15

// 示例 2：
// 输入：n = 4421
// 输出：21
// 解释： 
// 各位数之积 = 4 * 4 * 2 * 1 = 32 
// 各位数之和 = 4 + 4 + 2 + 1 = 11 
// 结果 = 32 - 11 = 21

// 提示：
// 1 <= n <= 10^5
#***************************************************************************************************************************
// self
function subtractProductAndSum($n)
{
    $n = str_split(strval($n));
    return intval(array_product($n) - array_sum($n));
}

// var_dump(subtractProductAndSum(4421));

// 执行结果：通过
// 执行用时 : 4 ms, 在所有 php 提交中击败了100.00%的用户
// 内存消耗 : 15.1 MB, 在所有 php 提交中击败了100.00%的用户

#***************************************************************************************************************************
# 6. 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
// 所谓无效化 IP 地址，其实就是用 "[.]" 代替了每个 "."。

// 示例 1：
// 输入：address = "1.1.1.1"
// 输出："1[.]1[.]1[.]1"

// 示例 2：
// 输入：address = "255.100.50.0"
// 输出："255[.]100[.]50[.]0"

// 提示：
// 给出的 address 是一个有效的 IPv4 地址
#***************************************************************************************************************************

// function defangIPaddr($address)
// {
//     return str_replace('.', '[.]', $address);
// }

// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了59.15%的用户
// 内存消耗 : 15 MB, 在所有 php 提交中击败了100.00%的用户


// function defangIPaddr($address)
// {
//     return implode('[.]', explode('.', $address));
// }

// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了59.15%的用户
// 内存消耗 : 15.1 MB, 在所有 php 提交中击败了100.00%的用户

// var_dump(defangIPaddr('265.0.1.2'));

#***************************************************************************************************************************
# 7. 直线上的最近距离
// 在一排座位（seats）中，1 代表有人坐在座位上，0 代表座位上是空的。
// 至少有一个空座位，且至少有一人坐在座位上。
// 亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。
// 返回他到离他最近的人的最大距离。

// 示例 1：
// 输入：[1,0,0,0,1,0,1]
// 输出：2
// 解释：
// 如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
// 如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
// 因此，他到离他最近的人的最大距离是 2 。 

// 示例 2：
// 输入：[1,0,0,0]
// 输出：3
// 解释： 
// 如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
// 这是可能的最大距离，所以答案是 3 。

// 提示：
// 1 <= seats.length <= 20000
// seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。
#***************************************************************************************************************************

// function maxDistToClosest($seats)
// {
// $minIndex = 0;
// $distance = array();
// foreach ($seats as $index => $value) {
//     if ($value == 1) {
//         $minIndex = $index;
//     } else {
//         $distance[] = $index - $minIndex;
//     }
// }

// return max($distance);
// }

function maxDistToClosest($seats)
{
    $maxRes = 0;
    $index = 0;
    $beforeIndex = 0;

    // beforeIndex记录空位置段的前一个坐了人的下标
    $seatsLength = count($seats);

    // 如果首端出现了连续的空位置段
    while ($seats[$index] == 0) {
        ++$index;
    }

    $maxRes = $index; // 坐在第一个位置
    while ($index < $seatsLength) {
        // 跳过坐了人的位置
        while ($index < $seatsLength && $seats[$index] == 1) {
            ++$index;
        }

        // 确定连续空位置区间
        $beforeIndex = $index - 1;
        while ($index < $seatsLength && $seats[$index] == 0) {
            ++$index;
        }

        // 更新最大结果
        if ($index == $seatsLength) {
            // 连续的空位置出现尾端，坐在尾端
            $maxRes = max($maxRes, $index - $beforeIndex - 1);
        } else {
            // 坐在空位置段的中间
            $maxRes = max($maxRes, ($index - $beforeIndex) / 2);
        }
    }

    return $maxRes;
}

var_dump(maxDistToClosest(array(1,0,0,0,1,0,1)));