<?php

#***************************************************************************************************************************
# 1. 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
// 说明:
// 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
// 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

// 示例:

// 输入:
// nums1 = [1,2,3,0,0,0], m = 3
// nums2 = [2,5,6],       n = 3

// 输出: [1,2,2,3,5,6]
// 示例:
// 给定 nums = [2, 7, 11, 15], target = 9
// 因为 nums[0] + nums[1] = 2 + 7 = 9
// 所以返回 [0, 1]
#***************************************************************************************************************************

// 方法一
// 最朴素的解法就是将两个数组合并之后再排序。时间复杂度较差，为O((n+m)log(n+m))。
// 这是由于这种方法没有利用两个数组本身已经有序这一点。

// 复杂度分析
// 时间复杂度 : O((n+m)log(n+m))。
// 空间复杂度 : O(1)

// function merge(&$nums1, $m, $nums2, $n)
// {
//     $nums1 = array_slice($nums1, 0, $m);
//     $nums1 = array_merge($nums1, $nums2);
//     sort($nums1);
// }


// 方法二
// 一般而言，对于有序数组可以通过 双指针法 达到O(n + m)的时间复杂度。
// 最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。
// 由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)的空间复杂度

// 复杂度分析
// 时间复杂度 : O(n + m)
// 空间复杂度 : O(m)

function merge(&$nums1, $m, $nums2, $n)
{
    $index1 = 0;
    $index2 = 0;
    $index3 = 0;

    $nums1Copy = array_slice($nums1, 0, $m);
    while ($index1 < $m && $index2 < $n) {
        $nums1[$index3++] = $nums1Copy[$index1] < $nums2[$index2] ? $nums1Copy[$index1++] : $nums2[$index2++];
    }

    if ($index1 < $m) {
        $nums1 = array_slice($nums1, 0, $index1 + $index2);
        $nums1 = array_merge($nums1, array_slice($nums1Copy, $index1, $m - $index1));
    }

    if ($index2 < $n) {
        $nums1 = array_slice($nums1, 0, $index1 + $index2);
        $nums1 = array_merge($nums1, array_slice($nums2, $index2, $n - $index2));
    }
}


// 方法三
// 方法二已经取得了最优的时间复杂度O(n + m)，但需要使用额外空间。这是由于在从头改变nums1的值时，
// 需要把nums1中的元素存放在其他位置。如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。
// 这里的指针 p 用于追踪添加元素的位置。

// 复杂度分析
// 时间复杂度 : O(n + m)
// 空间复杂度 : O(1)

// function merge(&$nums1, $m, $nums2, $n)
// {
//     $index1 = $m - 1;
//     $index2 = $n - 1;
//     $index3 = $m + $n - 1;

//     while ($index1 >= 0 && $index2 >= 0) {
//         $nums1[$index3--] = $nums1[$index1] < $nums2[$index2] ? $nums2[$index2--] : $nums1[$index1--];
//     }

//     sort($nums1);
// }

// $nums1 = array(1,2,3,0,0,0);
// $nums2 = array(2,5,6);
// merge($nums1, 3, $nums2, 3);
// var_dump($nums1);


#***************************************************************************************************************************
# 2. 杨辉三角（动态规划）
// 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
// 在杨辉三角中，每个数是它左上方和右上方的数的和。

// 输入: 5
// 输出:
// [
//      [1],
//     [1,1],
//    [1,2,1],
//   [1,3,3,1],
//  [1,4,6,4,1]
// ]

// [
//      [1],
//     [1,1],
//    [1,2,1],
//   [1,3,3,1],
//  [1,4,6,4,1]
// ]
#***************************************************************************************************************************

// 思路一：使用两层循环
// 0、外层循环决定有多少层。
// 1、内层循环决定没层的数据。
// 算法：
// 0、从0开始遍历每一层。
// 1、遍历当前层的时候，把当前层的数据存在临时变量tmp中，初始化为只有一个元素1的数组。 2、遍历当前层上层的元素，
// 每次把上层相邻的元素加和，追加到tmp中，初始化为只有一个元素1的数组。2、遍历当前层上层的元素，每次把上层相邻的元素加和，追加到tmp中。
// 3、当前层上层的元素遍历完成后，当前层的数据就生成完成，放到终止结果中。

// 复杂度分析
// 因为外层每次迭代的过程中,内层都要循环n次,即1+2+3+4+5+...,所以根据高斯公式 n(n+1)/2可得
// 时间复杂度：O(n^2)
function generate($numRows)
{
    $triangle = [];
    for ($i = 0; $i < $numRows; $i++) {
        $tmp = [1];
        for ($j = 0; $j < $i; $j++) {
            // 当$j = $i - 1的时候，已经说明已经是最后一个元素了，单独处理
            // 理论上$j == $i - 1的概率比较小，放到else效率应该更高，实际测试没有区别
            if ($j == $i - 1) {
                $tmp[] = $triangle[$i - 1][$j];
            } else {
                $tmp[] = $triangle[$i - 1][$j] + $triangle[$i - 1][$j + 1];
            }
        }

        $triangle[] = $tmp;
    }

    return $triangle;
}

// 解题思路二
// 思路二、动态规划

// 算法：
// 0、状态:
// dp[0] = [1];dp[1] = [1,1];
// 1、状态转移方程：
// dp[i][] = dp[i-1][j-1]+dp[i-1][j];

// function generate($numRows)
// {
//     if ($numRows == 0) {
//         return [];
//     }

//     if ($numRows == 1) {
//         return [[1]];
//     }

//     $dp[0] = [1];
//     $dp[1] = [1,1];
//     for($i = 2; $i < $numRows; $i++) {
//         $dp[$i][] = 1;
//         for($j = 1; $j < $i; $j++) {
//             $dp[$i][] = $dp[$i-1][$j-1]+$dp[$i-1][$j];
//         }
//         $dp[$i][] = 1;
//     }

//     return $dp;
// }

#***************************************************************************************************************************
# 3. 买卖股票的最佳时机
// 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
// 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

// 注意你不能在买入股票前卖出股票。

// 示例 1:
// 输入: [7,1,5,3,6,4]
// 输出: 5
// 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
//      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

// 示例 2:
// 输入: [7,6,4,3,1]
// 输出: 0
// 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
#***************************************************************************************************************************

// 我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。
// 形式上，对于每组 i 和 j（其中 j > i）我们需要找出 max(prices[j] - prices[i])。

// 方法一
// 暴力破解 运行超出时间显示
// 时间复杂度：O(n^2)；循环n(n - 1) / 2次
// 空间复杂度：O(1)
// function maxProfit($prices)
// {
//     $maxprofit = 0;
//     $length = count($prices);
//     for ($i = 0; $i < $length; $i++) {
//         for ($j = $i + 1; $j < $length; $j++) {
//             $profit = $prices[$j] - $prices[$i];
//             if ($profit > $maxprofit) {
//                 $maxprofit = $profit;
//             }
//         }
//     }
//     return $maxprofit;
// }

// 方法二
// 把数组中的数字画到纸上然后用直线连起来就会发现有波峰和波谷，然后我们只需要找到最小的谷之后的最大的峰。
// 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。

// 复杂度分析
// 时间复杂度：O(n)，只需要遍历一次。
// 空间复杂度：O(1)，只使用了两个变量。
function maxProfit($prices)
{
    $maxprofit = 0;
    $minprice = PHP_INT_MAX;
    $length = count($prices);
    for ($i = 0; $i < $length; $i++) {
        if ($prices[$i] < $minprice) {
            $minprice = $prices[$i];
        } else if ($prices[$i] - $minprice > $maxprofit) {
            $maxprofit = $prices[$i] - $minprice;
        }
    }
    return $maxprofit;
}

// $prices = [2,4,1];
// var_dump(maxProfit($prices));

#***************************************************************************************************************************
# 4. 罗马数字转整数
// 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
// 字符          数值
// I             1
// V             5
// X             10
// L             50
// C             100
// D             500
// M             1000
// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，
// 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

// I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
// X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
// C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
// 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

// 示例 1:
// 输入: "III"
// 输出: 3

// 示例 2:
// 输入: "IV"
// 输出: 4

// 示例 3:
// 输入: "IX"
// 输出: 9

// 示例 4:
// 输入: "LVIII"
// 输出: 58
// 解释: L = 50, V= 5, III = 3.

// 示例 5:
// 输入: "MCMXCIV"
// 输出: 1994
// 解释: M = 1000, CM = 900, XC = 90, IV = 4.
#***************************************************************************************************************************

// 方法一
function romanToInt($s)
{
    $result = 0;
    $strlength = strlen($s);
    $array = ['I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D' => 500, 'M' => 1000];
    for ($i = 0; $i < $strlength; $i++) {
        // 如果当前字符是字符串最后一个字符或者当前字符大于后一个字符时，直接加上当前字符的值；否则代表两个连续的字符的值
        if ($i + 1 >= $strlength || $array[$s[$i]] >= $array[$s[$i + 1]]) {
            $result += $array[$s[$i]];
        } else {
            $result += $array[$s[$i + 1]] - $array[$s[$i]];
            $i = $i + 1;
        }
    }
    return $result;
}

// 方法二： 遍历+双指针+哈希表映射
// function romanToInt($s) {
//     $array = ['I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D' => 500, 'M' => 1000];
//     $count = strlen($s);
//     $num = 0;
//     for ($i=0;$i<$count;$i++) {
//         $next = $i+1;
//         $num = $array[$s[$next]] > $array[$s[$i]] ? $num - $array[$s[$i]] : $num + $array[$s[$i]];
//     }
//     return $num;
// }

// 方法三：暴力破解，不如方法一、二巧妙
// function romanToInt($s)
// {
//     $gz = [
//         'I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D' => 500, 'M' => 1000,
//         'IV' => 4, 'IX' => 9, 'XL' => 40, 'XC' => 90, 'CD' => 400, 'CM' => 900,
//     ];

//     $num = 0;
//     $begin = 0;
//     while ($begin < strlen($s)) {
//         $tow_bit = substr($s, $begin, 2);
//         if (array_key_exists($tow_bit, $gz)) {
//             $num += $gz[$tow_bit];
//             $begin += 2;
//         } else {
//             $one_bit = substr($s, $begin, 1);
//             if (array_key_exists($one_bit, $gz)) {
//                 $num += $gz[$one_bit];
//                 $begin += 1;
//             }
//         }
//     }
//     return $num;
// }


#***************************************************************************************************************************
# 5. 杨辉三角 II
// 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。
// 在杨辉三角中，每个数是它左上方和右上方的数的和。

// 输入: 5
// 输出:
// [
//      [1],
//     [1,1],
//    [1,2,1],
//   [1,3,3,1],
//  [1,4,6,4,1]
// ]

// 进阶：
// 你可以优化你的算法到 O(k) 空间复杂度吗？  //TODO 未实现 没有思路
#***************************************************************************************************************************

function getRow($rowIndex)
{
    $rowIndex += 1;
    $triangle = array();
    for ($i = 0; $i < $rowIndex; $i++) {
        $temp[$i][0] = 1;
        for ($j = 0; $j < $i; $j++) {
            if ($j == $i - 1) {
                $temp[$i][] = $triangle[$i - 1][$j];
            } else {
                $temp[$i][] = $triangle[$i - 1][$j] + $triangle[$i - 1][$j + 1];
            }
        }

        $triangle = $temp;
        $temp = [];
    }

    return $triangle[$rowIndex - 1];
}

// var_dump(getRow(5));


#***************************************************************************************************************************
# 6. 最长公共前缀
// 编写一个函数来查找字符串数组中的最长公共前缀。
// 如果不存在公共前缀，返回空字符串 ""。

// 示例 1:
// 输入: ["flower","flow","flight"]
// 输出: "fl"

// 示例 2:
// 输入: ["dog","racecar","car"]
// 输出: ""

// 解释: 输入不存在公共前缀。

// 说明:
// 所有输入只包含小写字母 a-z 。
#***************************************************************************************************************************


// function longestCommonPrefix($strs) 
// {
    
// }


