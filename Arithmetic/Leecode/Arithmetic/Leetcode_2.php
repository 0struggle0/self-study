<?php

#***************************************************************************************************************************
# 1. 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。
// 说明:
// 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
// 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

// 示例:

// 输入:
// nums1 = [1,2,3,0,0,0], m = 3
// nums2 = [2,5,6],       n = 3

// 输出: [1,2,2,3,5,6]
// 示例:
// 给定 nums = [2, 7, 11, 15], target = 9
// 因为 nums[0] + nums[1] = 2 + 7 = 9
// 所以返回 [0, 1]
#***************************************************************************************************************************

// 方法一
// 最朴素的解法就是将两个数组合并之后再排序。时间复杂度较差，为O((n+m)log(n+m))。
// 这是由于这种方法没有利用两个数组本身已经有序这一点。

// 复杂度分析
// 时间复杂度 : O((n+m)log(n+m))。
// 空间复杂度 : O(1)

// function merge(&$nums1, $m, $nums2, $n)
// {
//     $nums1 = array_slice($nums1, 0, $m);
//     $nums1 = array_merge($nums1, $nums2);
//     sort($nums1);
// }


// 方法二
// 一般而言，对于有序数组可以通过 双指针法 达到O(n + m)的时间复杂度。
// 最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。
// 由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)的空间复杂度

// 复杂度分析
// 时间复杂度 : O(n + m)
// 空间复杂度 : O(m)

function merge(&$nums1, $m, $nums2, $n)
{
    $index1 = 0;
    $index2 = 0;
    $index3 = 0;

    $nums1Copy = array_slice($nums1, 0, $m);
    while ($index1 < $m && $index2 < $n) {
        $nums1[$index3++] = $nums1Copy[$index1] < $nums2[$index2] ? $nums1Copy[$index1++] : $nums2[$index2++];
    }

    if ($index1 < $m) {
        $nums1 = array_slice($nums1, 0, $index1 + $index2);
        $nums1 = array_merge($nums1, array_slice($nums1Copy, $index1, $m - $index1));
    }

    if ($index2 < $n) {
        $nums1 = array_slice($nums1, 0, $index1 + $index2);
        $nums1 = array_merge($nums1, array_slice($nums2, $index2, $n - $index2));
    }
}


// 方法三
// 方法二已经取得了最优的时间复杂度O(n + m)，但需要使用额外空间。这是由于在从头改变nums1的值时，
// 需要把nums1中的元素存放在其他位置。如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。
// 这里的指针 p 用于追踪添加元素的位置。

// 复杂度分析
// 时间复杂度 : O(n + m)
// 空间复杂度 : O(1)

// function merge(&$nums1, $m, $nums2, $n)
// {
//     $index1 = $m - 1;
//     $index2 = $n - 1;
//     $index3 = $m + $n - 1;

//     while ($index1 >= 0 && $index2 >= 0) {
//         $nums1[$index3--] = $nums1[$index1] < $nums2[$index2] ? $nums2[$index2--] : $nums1[$index1--];
//     }

//     sort($nums1);
// }

// $nums1 = array(1,2,3,0,0,0);
// $nums2 = array(2,5,6);
// merge($nums1, 3, $nums2, 3);
// var_dump($nums1);


#***************************************************************************************************************************
# 2. 杨辉三角
// 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。
// 在杨辉三角中，每个数是它左上方和右上方的数的和。

// 输入: 5
// 输出:
// [
//      [1],
//     [1,1],
//    [1,2,1],
//   [1,3,3,1],
//  [1,4,6,4,1]
// ]

// [
//      [1],
//     [1,1],
//    [1,2,1],
//   [1,3,3,1],
//  [1,4,6,4,1]
// ]
#***************************************************************************************************************************

function generate($numRows)
{
    $triangle = [];
    for ($i = 0; $i < $numRows; $i++) {
        $tmp = [1];
        for ($j = 0; $j < $i; $j++) {
            // 当$j = $i - 1的时候，已经说明已经是最后一个元素了，单独处理
            // 理论上$j == $i - 1的概率比较小，放到else效率应该更高，实际测试没有区别
            if ($j == $i - 1) {
                $tmp[] = $triangle[$i - 1][$j];
            } else {
                $tmp[] = $triangle[$i - 1][$j] + $triangle[$i - 1][$j + 1];
            }
        }

        $triangle[] = $tmp;
    }

    return $triangle;
}

var_dump(generate(5));