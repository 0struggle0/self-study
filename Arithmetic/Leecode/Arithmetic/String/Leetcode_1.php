<?php

#***************************************************************************************************************************
# 1. 删去字符串中的元音
// 示例:
// 输入："leetcodeisacommunityforcoders"
// 输出："ltcdscmmntyfrcdrs"
#***************************************************************************************************************************

// $initString = 'leetcodeisacommunityforcoders';
// $endString = str_replace(array('a', 'e', 'i', 'o', 'u'), '', $initString);
// var_dump($endString);

#***************************************************************************************************************************
# 2. 宝石与石头
// 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
// J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

// 示例 1:
// 输入: J = "aA", S = "aAAbbbb"
// 输出: 3
// 示例 2:

// 示例 2:
// 输入: J = "z", S = "ZZ"
// 输出: 0
// 注意:

// 提示：
// S 和 J 最多含有50个字母。
// J 中的字符不重复。
#***************************************************************************************************************************

// 方法一(self)
// function numJewelsInStones($J, $S) {
//     $JArray = str_split($J);
//     $SArray = str_split($S);
//     return count(array_intersect($SArray, $JArray));
// }
// 执行结果：通过
// 执行用时 : 4 ms, 在所有 php 提交中击败了 97.71% 的用户
// 内存消耗 : 15.1 MB, 在所有 php 提交中击败了 5.51% 的用户

// 方法二
// function numJewelsInStones($J, $S) {
//     return count(array_intersect(str_split($S), str_split($J)));
// }
// 有时代码行数少了不见得效率就高
// 执行结果：通过
// 执行用时 : 12 ms, 在所有 php 提交中击败了 27.43% 的用户
// 内存消耗 : 15 MB, 在所有 php 提交中击败了 5.51% 的用户

// 方法三
// function numJewelsInStones($J, $S) {
//     return strlen($S) - strlen(str_replace(str_split($J), '', $S));
// }
// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了 71.43% 的用户
// 内存消耗 : 14.8 MB, 在所有 php 提交中击败了 19.27% 的用户

// 方法四
// function numJewelsInStones($J, $S)
// {
//     $countJ = strlen($J);
//     if ($countJ == 0) {
//         return 0;
//     }

//     $out = 0;
//     $hash = [];
//     $countS = strlen($S);
//     for ($i = 0; $i < $countJ; $i++) {
//         $hash[$J[$i]] = 1;
//     }

//     for ($i = 0; $i < $countS; $i++) {
//         if (isset($hash[$S[$i]])) {
//             $out++;
//         }
//     }
//     return $out;
// }
// 执行结果：通过
// 执行用时 : 12 ms, 在所有 php 提交中击败了 27.43% 的用户
// 内存消耗 : 15 MB, 在所有 php 提交中击败了 5.51% 的用户

// 方法五
// function numJewelsInStones($J, $S)
// {
//     $bao = str_split($J);
//     $i = 0;
//     foreach ($bao as $v) {
//         $i += substr_count($S, $v);
//     }
//     return $i;
// }
// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了 71.43% 的用户
// 内存消耗 : 14.8 MB, 在所有 php 提交中击败了 26.61% 的用户


#***************************************************************************************************************************
# 3. 单行键盘
// 我们定制了一款特殊的力扣键盘，所有的键都排列在一行上。
// 我们可以按从左到右的顺序，用一个长度为 26 的字符串 keyboard （索引从 0 开始，到 25 结束）来表示该键盘的键位布局。
// 现在需要测试这个键盘是否能够有效工作，那么我们就需要个机械手来测试这个键盘。
// 最初的时候，机械手位于左边起第一个键（也就是索引为 0 的键）的上方。当机械手移动到某一字符所在的键位时，就会在终端上输出该字符。
// 机械手从索引 i 移动到索引 j 所需要的时间是 |i - j|。
// 当前测试需要你使用机械手输出指定的单词 word，请你编写一个函数来计算机械手输出该单词所需的时间。

// 示例 1:
// 输入：keyboard = "abcdefghijklmnopqrstuvwxyz", word = "cba"
// 输出：4
// 解释：
// 机械手从 0 号键移动到 2 号键来输出 'c'，又移动到 1 号键来输出 'b'，接着移动到 0 号键来输出 'a'。
// 总用时 = 2 + 1 + 1 = 4. 

// 示例 2:
// 输入：keyboard = "pqrstuvwxyzabcdefghijklmno", word = "leetcode"
// 输出：73

// 提示：
// keyboard.length == 26
// keyboard 按某种特定顺序排列，并包含每个小写英文字母一次。
// 1 <= word.length <= 10^4
// word[i] 是一个小写英文字母
#***************************************************************************************************************************
// function calculateTime($keyboard, $word)
// {
//     $time = 0;
//     $lastIndex = 0;
//     $wordLength = strlen($word);
//     for ($i = 0; $i < $wordLength; $i++) {
//         $currentIndex = strpos($keyboard, $word[$i]);
//         if ($currentIndex !== false) {
//             $time += abs($lastIndex - $currentIndex);
//             $lastIndex = $currentIndex;
//         }
//     }

//     return $time;
// }

// var_dump(calculateTime("pqrstuvwxyzabcdefghijklmno", "leetcode"));

#***************************************************************************************************************************
# 4. 整数的各位积和之差
// 给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。

// 示例 1：
// 输入：n = 234
// 输出：15 
// 解释：
// 各位数之积 = 2 * 3 * 4 = 24 
// 各位数之和 = 2 + 3 + 4 = 9 
// 结果 = 24 - 9 = 15

// 示例 2：
// 输入：n = 4421
// 输出：21
// 解释： 
// 各位数之积 = 4 * 4 * 2 * 1 = 32 
// 各位数之和 = 4 + 4 + 2 + 1 = 11 
// 结果 = 32 - 11 = 21

// 提示：
// 1 <= n <= 10^5
#***************************************************************************************************************************
// self
function subtractProductAndSum($n)
{
    $n = str_split(strval($n));
    return intval(array_product($n) - array_sum($n));
}

// var_dump(subtractProductAndSum(4421));

// 执行结果：通过
// 执行用时 : 4 ms, 在所有 php 提交中击败了100.00%的用户
// 内存消耗 : 15.1 MB, 在所有 php 提交中击败了100.00%的用户

#***************************************************************************************************************************
# 5. 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
// 所谓无效化 IP 地址，其实就是用 "[.]" 代替了每个 "."。

// 示例 1：
// 输入：address = "1.1.1.1"
// 输出："1[.]1[.]1[.]1"

// 示例 2：
// 输入：address = "255.100.50.0"
// 输出："255[.]100[.]50[.]0"

// 提示：
// 给出的 address 是一个有效的 IPv4 地址
#***************************************************************************************************************************

// function defangIPaddr($address)
// {
//     return str_replace('.', '[.]', $address);
// }

// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了59.15%的用户
// 内存消耗 : 15 MB, 在所有 php 提交中击败了100.00%的用户


// function defangIPaddr($address)
// {
//     return implode('[.]', explode('.', $address));
// }

// 执行结果：通过
// 执行用时 : 8 ms, 在所有 php 提交中击败了59.15%的用户
// 内存消耗 : 15.1 MB, 在所有 php 提交中击败了100.00%的用户

// var_dump(defangIPaddr('265.0.1.2'));


#***************************************************************************************************************************
# 6. 罗马数字转整数
// 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
// 字符          数值
// I             1
// V             5
// X             10
// L             50
// C             100
// D             500
// M             1000
// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，
// 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

// I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
// X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
// C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
// 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

// 示例 1:
// 输入: "III"
// 输出: 3

// 示例 2:
// 输入: "IV"
// 输出: 4

// 示例 3:
// 输入: "IX"
// 输出: 9

// 示例 4:
// 输入: "LVIII"
// 输出: 58
// 解释: L = 50, V= 5, III = 3.

// 示例 5:
// 输入: "MCMXCIV"
// 输出: 1994
// 解释: M = 1000, CM = 900, XC = 90, IV = 4.
#***************************************************************************************************************************

// 方法一
function romanToInt($s)
{
    $result = 0;
    $strlength = strlen($s);
    $array = ['I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D' => 500, 'M' => 1000];
    for ($i = 0; $i < $strlength; $i++) {
        // 如果当前字符是字符串最后一个字符或者当前字符大于后一个字符时，直接加上当前字符的值；否则代表两个连续的字符的值
        if ($i + 1 >= $strlength || $array[$s[$i]] >= $array[$s[$i + 1]]) {
            $result += $array[$s[$i]];
        } else {
            $result += $array[$s[$i + 1]] - $array[$s[$i]];
            $i = $i + 1;
        }
    }
    return $result;
}

// 方法二： 遍历+双指针+哈希表映射
// function romanToInt($s)
// {
//     $num = 0;
//     $count = strlen($s);
//     $array = ['I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D' => 500, 'M' => 1000];
//     for ($i = 0; $i < $count; $i++) {
//         $next = $i + 1;
//         $num = $array[$s[$next]] > $array[$s[$i]] ? $num - $array[$s[$i]] : $num + $array[$s[$i]];
//     }
//     return $num;
// }

// 方法三：暴力破解，不如方法一、二巧妙
// function romanToInt($s)
// {
//     $gz = [
//         'I' => 1, 'V' => 5, 'X' => 10, 'L' => 50, 'C' => 100, 'D' => 500, 'M' => 1000,
//         'IV' => 4, 'IX' => 9, 'XL' => 40, 'XC' => 90, 'CD' => 400, 'CM' => 900,
//     ];

//     $num = 0;
//     $begin = 0;
//     while ($begin < strlen($s)) {
//         $tow_bit = substr($s, $begin, 2);
//         if (array_key_exists($tow_bit, $gz)) {
//             $num += $gz[$tow_bit];
//             $begin += 2;
//         } else {
//             $one_bit = substr($s, $begin, 1);
//             if (array_key_exists($one_bit, $gz)) {
//                 $num += $gz[$one_bit];
//                 $begin += 1;
//             }
//         }
//     }
//     return $num;
// }

#***************************************************************************************************************************
# 7. 有效的括号
// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
// 有效字符串需满足：
// 左括号必须用相同类型的右括号闭合。
// 左括号必须以正确的顺序闭合。
// 注意空字符串可被认为是有效字符串。

// 示例 1:
// 输入: "()"
// 输出: true

// 示例 2:
// 输入: "()[]{}"
// 输出: true

// 示例 3:
// 输入: "(]"
// 输出: false

// 示例 4:
// 输入: "([)]"
// 输出: false

// 示例 5:
// 输入: "{[]}"
// 输出: true

// 示例 6
// 输入: "["
// 输出: false

// 示例 7
// 输入: ""
// 输出: true

// 示例 8
// 输入: "[{"
// 输出: false
#***************************************************************************************************************************

// self 方法一
// function isValid($s)
// {
//     $strlength = strlen($s);
//     // 奇数长度的字符串肯定不对
//     if ($strlength % 2 == 1) {
//         return false;
//     }

//     $temp = [];
//     $left = ['(' => ')', '[' => ']', '{' => '}'];
//     for ($i = 0; $i < $strlength; $i++) { 
//         // 利用栈先进后出的特性
//         if (isset($left[$s[$i]])) {
//             array_push($temp, $s[$i]); 
//         } else {
//             $leftString = array_pop($temp);
//             if ($left[$leftString] != $s[$i]) {
//                 return false;
//             }
//         }
//     }

//     // 偶数长度的字符串也不一定对, 因为可能遇到‘{(’这样的字符串, 所以需要判断数组全部出栈后的长度，如果长度大于0说明字符串内的括号不对称, 则返回false
//     return count($temp) == 0 ? true : false; 
// }

// 方法二
// 循环消消乐。。
function isValid($s)
{
    while (true) {
        $s = str_replace(['()', '[]', '{}'], '', $s, $count);
        if ($count == 0) {
            return strlen($s) == 0;
        }
    }
}

// 递归消消乐。。
// function isValid($s) {
//       $s = str_replace(['()','[]','{}'],'',$s,$count);
//       if($count==0){
//           return strlen($s)==0;
//       }else{
//           return $this->isValid($s);
//       }
//  }


var_dump(isValid('((()(())))'));


#***************************************************************************************************************************
# 8. 实现 strStr()
// 实现 strStr() 函数。
// 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

// 示例 1:
// 输入: haystack = "hello", needle = "ll"
// 输出: 2

// 示例 2:
// 输入: haystack = "aaaaa", needle = "bba"
// 输出: -1

// 说明:
// 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
// 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
#***************************************************************************************************************************

