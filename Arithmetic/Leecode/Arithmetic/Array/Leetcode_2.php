<?php

#***************************************************************************************************************************
# 1. 猜数字
// 小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？
// 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。

// 示例 1：
// 输入：guess = [1,2,3], answer = [1,2,3]
// 输出：3
// 解释：小A 每次都猜对了。

// 示例 2：
// 输入：guess = [2,2,3], answer = [3,2,1]
// 输出：1
// 解释：小A 只猜对了第二次。

// 限制：
// guess的长度 = 3
// answer的长度 = 3
// guess的元素取值为 {1, 2, 3} 之一。
// answer的元素取值为 {1, 2, 3} 之一。
#***************************************************************************************************************************

// $array1 = array(1, 2, 3);
// $array2 = array(1, 2, 3);

// 方法一
// $result = count(array_intersect_assoc($array1, $array2));

// 方法二  只适用于知道规模小的数据且有限
// $result = ($array1[0]==$array2[0]?1:0)+($array1[1]==$array2[1]?1:0)+($array1[2]==$array2[2]?1:0);
// var_dump($result);



#***************************************************************************************************************************
# 2. 多数元素 编号(编号 #169)
// 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
// 你可以假设数组是非空的，并且给定的数组总是存在多数元素。

// 示例 1:
// 输入: [3,2,3]
// 输出: 3

// 示例 2:
// 输入: [2,2,1,1,1,2,2]
// 输出: 2

// 本题题面中没有给出数据范围，但最简单的暴力方法（即枚举数组中的每个元素，再遍历一遍数组统计其出现次数，时间复杂度为 O(N^2)的算法）会超出时间限制，因此我们需要找出时间复杂度小于 O(N^2) 的优秀做法。
#***************************************************************************************************************************

// 方法一：哈希表
// 思路
// 我们知道出现次数最多的元素大于n/2次，所以可以用哈希表来快速统计每个元素出现的次数。

// 算法
// 我们使用哈希映射来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。
// 我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。

function majorityElement($nums) 
{
    $half = floor(count($nums) / 2);
    $counts = countNums($nums);
    foreach ($counts as $element => $time) {
        if ($time > $half) {
            return $element;
        }
    }
}

function countNums($nums)
{
    $hash = [];
    foreach ($nums as $num) {
        if (array_key_exists($num, $hash)) {
            $hash[$num] += 1;
        } else {
            $hash[$num] = 1;
        }
    }
    return $hash;
}

// 方法二：排序
// 思路
// 如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 n/2 的元素（下标从 0 开始）一定是众数。

// 算法
// 对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 nn 为奇数的情况，第二个例子是 nn 为偶数的情况。
// function majorityElement($nums) 
// {
//     sort($nums);
//     $length = count($nums);
//     return $nums[$length / 2];
// }



// function majorityElement($nums) 
// {
//     $countValues = array_count_values($nums);
//     $maxValueIndex = array_search(max($countValues), $countValues);
//     return $maxValueIndex;
// }

// $array = [3,2,3];
// $array = [2,2,1,1,1,2,2];
var_dump(majorityElement($array));